
#=
    Given an array of polynomials `polys` over a field of rational functions
    computes the Groebner basis of the ideal generated by polys.

    The algorithm is probabilistic and succeeds with a high probability.
=#
function paramgb(polys::Vector{T}) where {T}
    @assert !isempty(polys) "Empty input is invalid."
    Rx = parent(first(polys))
    Rfun = base_ring(Rx)
    # !(typeof(Rfun) <: typeof(Nemo.FracField)) && error("The input must be over a field of rational functions.")
    Rparam = base_ring(Rfun)
    K = base_ring(Rparam)
    metainfo = assert_input(polys, Rx, Rfun, Rparam, K)
    _paramgb(polys, metainfo)
end

function assert_input(polys, Rx, Raf, Ra, K)
    @assert all(x -> parent(x) == Rx, polys) "All polynomials must be in the same ring."
    is_finite_field = characteristic(K) != 0
    @assert typeof(K) in (Nemo.FlintRationalField, Nemo.GaloisField) "The base ring must be Nemo.QQ or a finite field."
    if !is_finite_field
        
    end
    if is_finite_field
        
    end
    (is_finite_field=is_finite_field,)
end

#=
    Parametric GB. The outline of the algorithm:
    
    1. Discover the monomials in the coefficients 
        of Groebner basis by specializing it at a random point.
    2. Discover the degrees of the coefficients 
        by specializing it at random points.
    3. For each coefficient in the basis 
        create a corresponding interpolator.
    4. Specialize the basis at a ``good'' point 
        and try to interpolate the coefficients.
    5. If the interpolation fails, go to 4.    
=#
function _paramgb(polys, metainfo)
    if metainfo.is_finite_field
        _paramgb_imodp(polys)
    else
        _paramgb_rationals(polys)
    end
end

function _paramgb_rationals(polys)
    i = 0
    shapegb = ShapeOfGb(polys)
    discover_monomials!(shapegb)
    discover_degrees!(shapegb)
    npoints = 0
    while true
        reducemodp!(shapegb)
        initialize_interpolators!(shapegb)
        while true
            i += 1
            @debug "Iteration $i"
            status = try_interpolate!(shapegb)
            if status.success
                break
            end
            npoints += status.npoints
            if ispow2(i)
                @info "$npoints points used.."
            end
        end
        @info "Success! $npoints points used."
        rationalreconstruct!(shapegb)
        if sanitycheck(shapegb)
            @info "Sanity check passed."
            break
        end
        @info "Sanity check failed. Trying again"
    end
    constructbasis(shapegb)
end

# Stores everything we need to know about the Groebner basis.
mutable struct ShapeOfGb{Poly1, Poly2, Poly3, Poly4}
    polys::Vector{Poly2}
    fracfreepolys::Vector{Poly1}
    specializedbasis::Vector{Poly3}
    shape::Vector{Vector{Poly3}}
    degrees::Vector{Vector{Tuple{Int, Int}}}
    interpolator
    prime::Int
    polysmodp::Vector{Poly4}
    count::Int
    polysreconstructed::Vector{Poly2}
end

function ShapeOfGb(polys::Vector{Poly}) where {Poly}
    Rx = parent(first(polys))
    Ra = base_ring(base_ring(Rx))
    K = base_ring(Ra)
    @info "Given $(length(polys)) polynomials in K(y)[x]"
    @info "Variables: $(gens(Rx))"
    @info "Parameters: $(gens(Ra))"
    # Remove denominators from the input by lifting it to a polynomial ring
    Rspec, _ = PolynomialRing(K, map(string, gens(Rx)))
    Rlifted, _ = PolynomialRing(Ra, map(string, gens(Rx)))
    fractionfreepolys = liftcoeffs(polys, Rlifted)
    @info "Lifting to K[y][x].."
    prime = 2^31-1
    Ramodp,_ = PolynomialRing(GF(prime), map(string, gens(Ra)))
    Rxmodp, _ = PolynomialRing(Ramodp, map(string, gens(Rx)))
    ShapeOfGb(
        polys,
        fractionfreepolys, 
        Vector{elem_type(Ramodp)}(), 
        Vector{Vector{elem_type(Ramodp)}}(), 
        Vector{Vector{Tuple{Int, Int}}}(),
        0,
        prime,
        Vector{elem_type(Rxmodp)}(),
        0,
        Vector{elem_type(Rx)}(),
    )
end

function reducemodp!(shapeof::ShapeOfGb)
    @info "Reducing modulo $(shapeof.prime).."
    ff = GF(shapeof.prime)
    shapeof.prime = Primes.nextprime(shapeof.prime + 1)
    resize!(shapeof.polysmodp, length(shapeof.polys))
    for i in 1:length(shapeof.fracfreepolys)
        shapeof.polysmodp[i] = map_coefficients(f -> map_coefficients(c -> ff(c), f), shapeof.fracfreepolys[i])
    end
    nothing
end

function rationalreconstruct!(shapeof::ShapeOfGb)
    Rx = parent(first(shapeof.polys))
    Rparam = base_ring(Rx)
    polysreconstructed = Vector{elem_type(Rx)}(undef, length(shapeof.shape))
    p = Int(characteristic(base_ring(parent(ExactSparseInterpolations.getresult(shapeof.interpolator, 1)[2]))))
    acc = 0
    for i in 1:length(shapeof.shape)
        coeffsrec = Vector{elem_type(Rparam)}(undef, length(shapeof.shape[i]))
        for j in 1:length(shapeof.shape[i])
            idx = acc + j
            flag, P, Q = ExactSparseInterpolations.getresult(shapeof.interpolator, idx)
            @assert flag
            Prec = map_coefficients(c -> rational_reconstruction(Int(data(c)), p), P)
            Qrec = map_coefficients(c -> rational_reconstruction(Int(data(c)), p), Q)
            coeffsrec[j] = Prec // Qrec
        end
        polysreconstructed[i] = Rx(coeffsrec, map(e -> exponent_vector(e, 1), shapeof.shape[i]))
        acc += length(shapeof.shape[i])
    end
    shapeof.polysreconstructed = polysreconstructed
    nothing
end

function constructbasis(shapeof::ShapeOfGb)
    shapeof.polysreconstructed
end

function initialize_interpolators!(shapegb::ShapeOfGb)
    @info "Initializing interpolation routines.."
    Rparammodp = base_ring(parent(first(shapegb.polysmodp)))
    N, D = 0, 0
    for i in 1:length(shapegb.degrees)
        for j in 1:length(shapegb.degrees[i])
            N = max(N, shapegb.degrees[i][j][1])
            D = max(D, shapegb.degrees[i][j][2])
        end
    end
    count = sum(map(length, shapegb.degrees))
    @info "Interpolating $count coefficients at once. Interpolation is bound by degrees $N, $D"
    shapegb.count = count
    shapegb.interpolator = ExactSparseInterpolations.SimultaneousAdaptiveVanDerHoevenLecerf(Rparammodp, count, N, D)
end

function try_interpolate!(shapegb::ShapeOfGb)
    K = base_ring(base_ring(parent(first(shapegb.polysmodp))))
    xs = ExactSparseInterpolations.nextpoints!(shapegb.interpolator)
    vals = Vector{Vector{elem_type(K)}}(undef, shapegb.count)
    for i in 1:shapegb.count
        vals[i] = Vector{elem_type(K)}(undef, length(xs))
    end
    for (ii, x) in enumerate(xs)
        Ip = specializemodp(shapegb, x)
        basis = groebner(Ip)
        acc = 0
        for i in 1:length(basis)
            for j in 1:length(basis[i])
                idx = acc + j
                vals[idx][ii] = coeff(basis[i], j)
            end
            acc += length(basis[i])
        end
    end
    ExactSparseInterpolations.nextevaluations!(shapegb.interpolator, vals)
    (success=ExactSparseInterpolations.allready(shapegb.interpolator), npoints=length(xs),)
end

function liftcoeffs(polys, newring)
    cfs = map(collect ∘ coefficients, polys)
    cfs = map(c -> map(numerator, c .* lcm(map(denominator, c))), cfs)
    newpolys = Vector{elem_type(newring)}(undef, length(polys))
    for i in 1:length(newpolys)
        G = lcm(map(denominator, collect(coefficients(polys[i]))))
        newpolys[i] = map_coefficients(c -> numerator(c * G), polys[i])
    end
    newpolys
end

function randpoint(shapegb::ShapeOfGb)
    FF = base_ring(parent(first(shapegb.fracfreepolys)))
    point = ExactSparseInterpolations.random_point(FF)
    point
end

function randpointmodp(shapegb::ShapeOfGb)
    FF = base_ring(parent(first(shapegb.polysmodp)))
    point = ExactSparseInterpolations.random_point(FF)
    point
end

function specialize(shapegb::ShapeOfGb, point)
    map(f -> map_coefficients(c -> evaluate(c, point), f), shapegb.fracfreepolys)
end

function specializemodp(shapegb::ShapeOfGb, point)
    map(f -> map_coefficients(c -> evaluate(c, point), f), shapegb.polysmodp)
end

function majorrule(bases::Vector{Vector{Poly}}) where {Poly}
    if length(bases) == 1
        return first(bases)
    end
    # placeholder for now
    first(bases)
end

function assert_shape(shapeof::ShapeOfGb, basis)
    shapeof.shape == basisshape(basis)
end

function sanitycheck(x)
    true
end

function basisshape(basis)
    [collect(monomials(f)) for f in basis]
end

#=
    Discovers the exponents in the groebner basis
    by specializing it at a random point.

    If η > 0 is given, the algorithm will confirm the shape
    by additionaly specializing it at η random points.
=#
function discover_monomials!(shapegb::ShapeOfGb; η=2)
    iszero(η) && (@warn "Deciding the shape of the basis from 1 point is adventurous.")
    @info "Specializing at $(1) + $(η) random points to guess the shape.."
    reducemodp!(shapegb)
    specializations = map(_ -> specializemodp(shapegb, randpointmodp(shapegb)), 1:1 + η)
    bases = map(groebner, specializations)
    basis = majorrule(bases)
    shapegb.shape = basisshape(basis)
    @info "The shape of the basis is: $(length(basis)) polynomials with monomials" shapegb.shape
    @debug "" shapegb.shape
    shapegb.shape
end

#=
    Discovers the exponents in the groebner basis
    by specializing it at random points.

    If η > 0 is given, the algorithm will take η 
    additional steps in the interpolation to confirm the degrees.
=#
function discover_degrees!(shapegb::ShapeOfGb; η=2)
    @info "Specializing at random points to guess the exponents in the coefficients.."
    Ru, _ = PolynomialRing(base_ring(base_ring(first(shapegb.polysmodp))), :u)
    interpolators = [
        [
            ExactSparseInterpolations.AdaptiveCauchy(Ru)
            for _ in 1:length(shapegb.shape[i])
        ]
        for i in 1:length(shapegb.shape)
    ]
    statuses = [
        [false for _ in 1:length(shapegb.shape[i])]
        for i in 1:length(shapegb.shape)
    ]
    ηs = [
        [η for _ in 1:length(shapegb.shape[i])]
        for i in 1:length(shapegb.shape)
    ]
    degrees = [
        [(-1, -1) for _ in 1:length(shapegb.shape[i])]
        for i in 1:length(shapegb.shape)
    ]
    one_of_a_kind = ExactSparseInterpolations.AdaptiveCauchy(Ru)
    all_interpolated = false
    a = randpointmodp(shapegb)
    s = randpointmodp(shapegb)
    ip = 0
    while !all_interpolated
        ip += 1
        if ispow2(ip)
            @info "$ip points used.."
        end
        x_point = ExactSparseInterpolations.next_point!(one_of_a_kind)
        # shift !!!
        Ip = specializemodp(shapegb, a .* x_point .+ s)
        basis = groebner(Ip)
        # !assert_shape!(shapegb, basis) && continue
        for i in 1:length(basis)
            for (j, (interpolator, status)) in enumerate(zip(interpolators[i], statuses[i]))
                # if already interpolated
                status && continue
                y_point = coeff(basis[i], j)
                success, (P, Q) = ExactSparseInterpolations.next!(interpolator, x_point, y_point)
                degrees[i][j] = (degree(P), degree(Q))
                statuses[i][j] = success
                # if more than one consecutive success is needed
                if success && !iszero(ηs[i][j])
                    statuses[i][j] = false
                    ηs[i][j] -= 1
                end
            end
        end
        all_interpolated = all(map(all, statuses))
    end
    shapegb.degrees = degrees
    @info "Success! $(ip) points used."
    @info "The exponents in the coefficients" degrees
    shapegb.degrees
end
