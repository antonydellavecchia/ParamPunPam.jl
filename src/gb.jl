
#=
    Given an array of polynomials `polys` 
    over a field of rational functions modulo a prime
    computes the Groebner basis of the ideal generated by polys.

    The algorithm is probabilistic and succeeds with a high probability.
=#
function paramgb(polys::Vector{T}) where {T}
    @assert !isempty(polys) "Empty input is invalid."
    Rx = parent(first(polys))
    Ra = base_ring(Rx)
    @assert nvars(base_ring(Ra)) > 0 "Non-parametric input is not supported, sorry."
    K = base_ring(Ra)
    _paramgb(polys)
end

#=
    Parametric GB. The outline of the algorithm:
    
    1. Discover the monomials in the Groebner basis 
        by specializing it at a random point.
    2. Discover the degrees of the coefficients 
        by specializing it at random points.
    3. For each coefficient in the basis 
        create a corresponding interpolator.
    4. Specialize the basis at a ``good'' point 
        and try to interpolate the coefficients.
    5. If the interpolation fails, go to 4.    
=#
function _paramgb(polys)
    i = 0
    shapegb = ShapeOfGb(polys)
    discover_monomials!(shapegb)
    discover_degrees!(shapegb)
    initialize_interpolators!(shapegb)
    while true
        i += 1
        @debug "Iteration $i"
        success = try_interpolate!(shapegb)
        if ispow2(i)
            @info "$i points used.."
        end
        if success
            break
        end
    end
    @info "Success! $i points used."
    constructbasis(shapegb)
end

# Stores everything we need to know about the Groebner basis.
mutable struct ShapeOfGb{Poly1, Poly2, PolySpec, Monom, I}
    polys::Vector{Poly2}
    fracfreepolys::Vector{Poly1}
    specializedbasis::Vector{PolySpec}
    shape::Vector{Vector{Monom}}
    degrees::Vector{Vector{Tuple{Int, Int}}}
    interpolators::Vector{Vector{I}}
    statuses::Vector{Vector{Bool}}
    interpolatedcoeffs::Vector{Vector{Tuple{PolySpec, PolySpec}}}
end

function ShapeOfGb(polys::Vector{Poly}) where {Poly}
    Rx = parent(first(polys))
    Ra = base_ring(base_ring(Rx))
    K = base_ring(Ra)
    @info "Given $(length(polys)) polynomials in K(y)[x]"
    @info "Variables: $(gens(Rx))"
    @info "Parameters: $(gens(Ra))"
    # Remove denominators from the input by lifting it to a polynomial ring
    Rspec, _ = PolynomialRing(K, map(string, gens(Rx)))
    Rlifted, _ = PolynomialRing(Ra, map(string, gens(Rx)))
    fractionfreepolys = liftcoeffs(polys, Rlifted)
    @info "Lifting to K[y][x]" fractionfreepolys
    ShapeOfGb(
        polys,
        fractionfreepolys, 
        Vector{elem_type(Rspec)}(), 
        Vector{Vector{elem_type(Rspec)}}(), 
        Vector{Vector{Tuple{Int, Int}}}(),
        Vector{Vector{Any}}(),
        Vector{Vector{Bool}}(),
        Vector{Vector{Tuple{elem_type(Ra), elem_type(Ra)}}}()
    )
end

function constructbasis(shapeof::ShapeOfGb)
    Rparam = parent(first(shapeof.polys))
    xs = gens(Rparam)
    ps = gens(base_ring(base_ring(Rparam)))
    basis = Vector{elem_type(Rparam)}(undef, length(shapeof.shape))
    for i in 1:length(shapeof.shape)
        basis[i] = zero(Rparam)
        for j in 1:length(shapeof.shape[i])
            cf = evaluate(shapeof.interpolatedcoeffs[i][j][1], ps) // evaluate(shapeof.interpolatedcoeffs[i][j][2], ps)
            mn = evaluate(shapeof.shape[i][j], xs)
            basis[i] += cf * mn
        end
    end
    basis
end

function initialize_interpolators!(shapegb::ShapeOfGb)
    @info "Initializing interpolation routines.."
    Rparam = base_ring(parent(first(shapegb.fracfreepolys)))
    resize!(shapegb.interpolators, length(shapegb.degrees))
    resize!(shapegb.statuses, length(shapegb.degrees))
    resize!(shapegb.interpolatedcoeffs, length(shapegb.degrees))
    M = maximum(map(c -> maximum(map(maximum, c)), shapegb.degrees))
    @info "Interpolation is bound by degrees $M, $M"
    one_of_a_kind = ExactSparseInterpolations.adaptiveVanDerHoevenLecerf(Rparam, M, M)
    for i in 1:length(shapegb.degrees)
        shapegb.interpolatedcoeffs[i] = Vector{Tuple{elem_type(Rparam), elem_type(Rparam)}}(undef, length(shapegb.degrees[i]))
        shapegb.statuses[i] = falses(length(shapegb.degrees[i]))
        shapegb.interpolators[i] = Vector{Any}(undef, length(shapegb.degrees[i]))
        for j in 1:length(shapegb.degrees[i])
            shapegb.interpolatedcoeffs[i][j] = (zero(Rparam), zero(Rparam))
            shapegb.interpolators[i][j] = ExactSparseInterpolations.adaptiveVanDerHoevenLecerf(Rparam, M, M)
        end
    end
    shapegb.interpolators
end

function try_interpolate!(shapegb::ShapeOfGb)
    one_of_a_kind = first(first(shapegb.interpolators))
    x_point = ExactSparseInterpolations.next_point!(one_of_a_kind)
    for ii in shapegb.interpolators
        for (ij, iii) in enumerate(ii)
            ij == 1 && continue
            ExactSparseInterpolations.next_point!(iii)
        end
        ExactSparseInterpolations.synchronize!(one_of_a_kind, ii)
    end
    Ip = specialize(shapegb, x_point)
    basis = groebner(Ip)
    # !assert_shape!(shapegb, basis) && continue
    for i in 1:length(basis)
        for (j, (interpolator, status)) in enumerate(zip(shapegb.interpolators[i], shapegb.statuses[i]))
            # if already interpolated
            status && continue
            y_point = coeff(basis[i], j)
            success, (P, Q) = ExactSparseInterpolations.next!(interpolator, y_point)
            # if (i, j) == (1, 2)
            #     @info "" P Q
            # end
            # success = success && (total_degree(P), total_degree(Q)) == shapegb.degrees[i][j]
            shapegb.statuses[i][j] = success
            if success
                @warn "Coefficient basis[$i][$j] is interpolated!" P//Q
                shapegb.interpolatedcoeffs[i][j] = (P, Q)
            end
        end
    end
    all(map(all, shapegb.statuses))
end

function liftcoeffs(polys, newring)
    cfs = map(collect ∘ coefficients, polys)
    cfs = map(c -> map(numerator, c .* lcm(map(denominator, c))), cfs)
    newpolys = Vector{elem_type(newring)}(undef, length(polys))
    for i in 1:length(newpolys)
        G = lcm(map(denominator, collect(coefficients(polys[i]))))
        newpolys[i] = map_coefficients(c -> numerator(c * G), polys[i])
    end
    newpolys
end

function randpoint(shapegb::ShapeOfGb)
    FF = base_ring(parent(first(shapegb.fracfreepolys)))
    point = ExactSparseInterpolations.random_point(FF)
    point
end

function specialize(shapegb::ShapeOfGb, point)
    map(f -> map_coefficients(c -> evaluate(c, point), f), shapegb.fracfreepolys)
end

function majorrule(bases::Vector{Vector{Poly}}) where {Poly}
    if length(bases) == 1
        return first(bases)
    end
    # placeholder for now
    first(bases)
end

function shapeof(basis)
    [collect(monomials(f)) for f in basis]
end

#=
    Discovers the exponents in the groebner basis
    by specializing it at a random point.

    If η > 0 is given, the algorithm will confirm the shape
    by additionaly specializing it at η random points.
=#
function discover_monomials!(shapegb::ShapeOfGb; η=2)
    iszero(η) && (@warn "Deciding the shape of the basis from 1 point is adventurous.")
    @info "Specializing at $(1) + $(η) random points to guess the shape.."
    specializations = map(_ -> specialize(shapegb, randpoint(shapegb)), 1:1 + η)
    bases = map(groebner, specializations)
    basis = majorrule(bases)
    shapegb.shape = shapeof(basis)
    @info "The shape of the basis is: $(length(basis)) polynomials with monomials" shapegb.shape
    @debug "" shapegb.shape
    shapegb.shape
end

#=
    Discovers the exponents in the groebner basis
    by specializing it at random points.

    If η > 0 is given, the algorithm will take η 
    additional steps in the interpolation to confirm the degrees.
=#
function discover_degrees!(shapegb::ShapeOfGb; η=2)
    @info "Specializing at random points to guess the exponents in the coefficients.."
    Ru, _ = PolynomialRing(base_ring(base_ring(first(shapegb.fracfreepolys))), :u)
    interpolators = [
        [
            ExactSparseInterpolations.AdaptiveCauchy(Ru)
            for _ in 1:length(shapegb.shape[i])
        ]
        for i in 1:length(shapegb.shape)
    ]
    statuses = [
        [false for _ in 1:length(shapegb.shape[i])]
        for i in 1:length(shapegb.shape)
    ]
    ηs = [
        [η for _ in 1:length(shapegb.shape[i])]
        for i in 1:length(shapegb.shape)
    ]
    degrees = [
        [(-1, -1) for _ in 1:length(shapegb.shape[i])]
        for i in 1:length(shapegb.shape)
    ]
    one_of_a_kind = ExactSparseInterpolations.AdaptiveCauchy(Ru)
    all_interpolated = false
    a = randpoint(shapegb)
    s = randpoint(shapegb)
    while !all_interpolated
        x_point = ExactSparseInterpolations.next_point!(one_of_a_kind)
        # shift !!!
        Ip = specialize(shapegb, a .* x_point .+ s)
        basis = groebner(Ip)
        # !assert_shape!(shapegb, basis) && continue
        for i in 1:length(basis)
            for (j, (interpolator, status)) in enumerate(zip(interpolators[i], statuses[i]))
                # if already interpolated
                status && continue
                y_point = coeff(basis[i], j)
                success, (P, Q) = ExactSparseInterpolations.next!(interpolator, x_point, y_point)
                degrees[i][j] = (degree(P), degree(Q))
                statuses[i][j] = success
                # if more than one consecutive success is needed
                if success && !iszero(ηs[i][j])
                    statuses[i][j] = false
                    ηs[i][j] -= 1
                end
            end
        end
        all_interpolated = all(map(all, statuses))
    end
    shapegb.degrees = degrees
    @info "The exponents in the coefficients" degrees
    shapegb.degrees
end
